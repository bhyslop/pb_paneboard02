<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified">

  <!-- ðŸŸ¦ FORM: the complete designed system -->
  <xs:element name="Form">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="Measure" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="Space" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="Frame" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="Layout" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element ref="Binding" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!--
    ðŸŸ« MEASURE: Named pixel constants

    Defines reusable pixel values that can be referenced by name in dimension
    constraints (minWidth, minHeight, underWidth, underHeight).

    Example:
      <Measure name="hdWidth" value="1920"/>
      <Space name="Large">
        <Match minWidth="hdWidth"/>  <!-- references the measure -->
      </Space>
  -->
  <xs:element name="Measure">
    <xs:complexType>
      <xs:attribute name="name" type="xs:string" use="required"/>
      <xs:attribute name="value" type="xs:positiveInteger" use="required"/>
    </xs:complexType>
  </xs:element>

  <!-- MeasureReference: either a Measure name or literal pixel value -->
  <xs:simpleType name="MeasureReference">
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9]+|[a-zA-Z_][a-zA-Z0-9_]*"/>
    </xs:restriction>
  </xs:simpleType>

  <!--
    ðŸŸ© SPACE: Physical display environment definitions

    A Space defines matching rules for physical displays based on properties like
    resolution, orientation, and name. Layouts can reference Spaces to activate only
    on appropriate displays.

    Matching logic:
    - Multiple <Match> elements are OR'd: any Match succeeds â†’ display is candidate
    - Within a single Match, all attributes are AND'd: all must be true
    - Multiple <Exclude> elements are OR'd: any Exclude vetoes the match
    - Within a single Exclude, all attributes are AND'd
    - Final result: (any Match passes) AND (no Exclude vetoes) = display matches Space

    Example:
      <Space name="LargeDisplays">
        <Match minWidth="1920" minHeight="1080" whenOrientation="landscape"/>
        <Match minWidth="1080" minHeight="1920" whenOrientation="portrait"/>
        <Exclude nameContains="Built-in"/>
      </Space>

    This matches displays that are:
      - (â‰¥1920Ã—1080 landscape) OR (â‰¥1080Ã—1920 portrait)
      - AND NOT named with "Built-in"
  -->
  <xs:element name="Space">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="Match"   type="SpaceRule" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="Exclude" type="SpaceRule" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attribute name="name" type="xs:string" use="required"/>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="SpaceRule">
    <xs:attribute name="nameContains" type="xs:string" use="optional"/>
    <xs:attribute name="whenOrientation" use="optional">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="portrait"/>
          <xs:enumeration value="landscape"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <!-- Dimension constraints: min is inclusive (>=), under is exclusive (<) -->
    <xs:attribute name="minWidth"    type="MeasureReference" use="optional"/>
    <xs:attribute name="minHeight"   type="MeasureReference" use="optional"/>
    <xs:attribute name="underWidth"  type="MeasureReference" use="optional"/>
    <xs:attribute name="underHeight" type="MeasureReference" use="optional"/>
  </xs:complexType>

  <!--
    ðŸŸ¨ FRAME: Reusable geometric patterns

    A Frame defines a collection of Pane geometries that can be referenced by Shapes
    within Layouts. Each Pane specifies its position and size as percentages of the
    display's visible frame.

    Example:
      <Frame id="sidebar">
        <Pane x="0" y="0" width="30" height="100"/>
        <Pane x="30" y="0" width="70" height="100"/>
      </Frame>
  -->
  <xs:element name="Frame">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="Pane" type="PaneType" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:string" use="required"/>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="PaneType">
    <xs:attribute name="x"      type="PercentType" use="required"/>
    <xs:attribute name="y"      type="PercentType" use="required"/>
    <xs:attribute name="width"  type="PercentType" use="required"/>
    <xs:attribute name="height" type="PercentType" use="required"/>
  </xs:complexType>

  <!--
    PercentType: Percentage values (0-100) for Pane geometry

    Currently defines percentages of the display's visible frame.

    Note: Future versions may support numerator/divisor notation (e.g., "1/3")
    alongside or instead of decimal percentages.
  -->
  <xs:simpleType name="PercentType">
    <xs:restriction base="xs:decimal">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="100"/>
    </xs:restriction>
  </xs:simpleType>

  <!--
    ðŸŸ¥ LAYOUT: Composition of frames into shapes

    A Layout defines how windows are tiled on a display. It contains a tree of Shapes
    that reference Frames and can be conditionally applied based on display properties.

    The optional 'space' attribute references a Space by name. When specified, the
    Layout only activates on displays that match that Space. When omitted, the Layout
    applies to all displays.

    Example:
      <Layout id="sidebar-split" space="LargeDisplays">
        <Shape frame="sidebar"/>
      </Layout>
  -->
  <xs:element name="Layout">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="Shape" type="ShapeType" minOccurs="1" maxOccurs="1"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:string" use="required"/>
      <xs:attribute name="space" type="xs:string" use="optional"/> <!-- references Space/@name -->
    </xs:complexType>
  </xs:element>

  <!--
    ShapeType: Hierarchical pane layout with conditional evaluation

    Shapes form a tree structure that defines how windows are tiled:

    1. A Shape with frame="foo" references a Frame by id
    2. Child Shapes map 1:1 to the parent Frame's Panes (in order)
    3. Each child Shape subdivides its corresponding parent Pane
    4. If child Shape has no 'frame' attribute, that Pane is not subdivided
    5. Extra child Shapes (beyond parent Pane count) are ignored
    6. Missing child Shapes mean remaining Panes are not subdivided

    Conditional attributes (whenOrientation, min/underWidth/Height) allow Shapes
    to be pruned based on display properties. If a Shape's conditions don't match,
    it and its entire subtree are excluded from the layout.

    Example:
      <Shape frame="sidebar">
        <Shape frame="leftColumn"/>   <!-- subdivides first Pane -->
        <Shape/>                       <!-- second Pane not subdivided -->
      </Shape>
  -->
  <xs:complexType name="ShapeType">
    <xs:sequence>
      <xs:element name="Shape" type="ShapeType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="frame" type="xs:string" use="optional"/> <!-- references Frame/@id -->
    <xs:attribute name="whenOrientation" use="optional">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="portrait"/>
          <xs:enumeration value="landscape"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <!-- Dimension constraints: min is inclusive (>=), under is exclusive (<) -->
    <xs:attribute name="minWidth"    type="MeasureReference" use="optional"/>
    <xs:attribute name="minHeight"   type="MeasureReference" use="optional"/>
    <xs:attribute name="underWidth"  type="MeasureReference" use="optional"/>
    <xs:attribute name="underHeight" type="MeasureReference" use="optional"/>
  </xs:complexType>

  <!--
    KeyType: Valid unmodified keys for bindings

    Rationale:
    - Only keys present on both full-size Mac and PC keyboards
    - Excludes platform-specific keys (eject, insert, printscreen)
    - Excludes modifier keys (shift, alt, option, command, control)
    - Excludes fn-chord-dependent keys (Mac fn+delete â†’ PC delete handled separately)
    - Letters are lowercase; shifted variants handled by modifier configuration
    - Punctuation spelled out for clarity (e.g., "period" not ".")
    - Includes numpad for users with full keyboards
    - Function keys limited to F1-F12 (ubiquitous on both platforms)
  -->
  <xs:simpleType name="KeyType">
    <xs:restriction base="xs:string">
      <!-- Letters (lowercase) -->
      <xs:enumeration value="a"/>
      <xs:enumeration value="b"/>
      <xs:enumeration value="c"/>
      <xs:enumeration value="d"/>
      <xs:enumeration value="e"/>
      <xs:enumeration value="f"/>
      <xs:enumeration value="g"/>
      <xs:enumeration value="h"/>
      <xs:enumeration value="i"/>
      <xs:enumeration value="j"/>
      <xs:enumeration value="k"/>
      <xs:enumeration value="l"/>
      <xs:enumeration value="m"/>
      <xs:enumeration value="n"/>
      <xs:enumeration value="o"/>
      <xs:enumeration value="p"/>
      <xs:enumeration value="q"/>
      <xs:enumeration value="r"/>
      <xs:enumeration value="s"/>
      <xs:enumeration value="t"/>
      <xs:enumeration value="u"/>
      <xs:enumeration value="v"/>
      <xs:enumeration value="w"/>
      <xs:enumeration value="x"/>
      <xs:enumeration value="y"/>
      <xs:enumeration value="z"/>

      <!-- Digits (unshifted) -->
      <xs:enumeration value="0"/>
      <xs:enumeration value="1"/>
      <xs:enumeration value="2"/>
      <xs:enumeration value="3"/>
      <xs:enumeration value="4"/>
      <xs:enumeration value="5"/>
      <xs:enumeration value="6"/>
      <xs:enumeration value="7"/>
      <xs:enumeration value="8"/>
      <xs:enumeration value="9"/>

      <!-- Function keys (F1-F12 only, ubiquitous) -->
      <xs:enumeration value="f1"/>
      <xs:enumeration value="f2"/>
      <xs:enumeration value="f3"/>
      <xs:enumeration value="f4"/>
      <xs:enumeration value="f5"/>
      <xs:enumeration value="f6"/>
      <xs:enumeration value="f7"/>
      <xs:enumeration value="f8"/>
      <xs:enumeration value="f9"/>
      <xs:enumeration value="f10"/>
      <xs:enumeration value="f11"/>
      <xs:enumeration value="f12"/>

      <!-- Navigation: arrows -->
      <xs:enumeration value="up"/>
      <xs:enumeration value="down"/>
      <xs:enumeration value="left"/>
      <xs:enumeration value="right"/>

      <!-- Navigation: other -->
      <xs:enumeration value="home"/>
      <xs:enumeration value="end"/>
      <xs:enumeration value="pageup"/>
      <xs:enumeration value="pagedown"/>

      <!-- Editing/Control -->
      <xs:enumeration value="escape"/>
      <xs:enumeration value="tab"/>
      <xs:enumeration value="space"/>
      <xs:enumeration value="enter"/>
      <xs:enumeration value="backspace"/>
      <xs:enumeration value="delete"/>

      <!-- Punctuation (unshifted, spelled out) -->
      <xs:enumeration value="grave"/>
      <xs:enumeration value="minus"/>
      <xs:enumeration value="equals"/>
      <xs:enumeration value="leftbracket"/>
      <xs:enumeration value="rightbracket"/>
      <xs:enumeration value="backslash"/>
      <xs:enumeration value="semicolon"/>
      <xs:enumeration value="apostrophe"/>
      <xs:enumeration value="comma"/>
      <xs:enumeration value="period"/>
      <xs:enumeration value="slash"/>

      <!-- Numpad -->
      <xs:enumeration value="numpad0"/>
      <xs:enumeration value="numpad1"/>
      <xs:enumeration value="numpad2"/>
      <xs:enumeration value="numpad3"/>
      <xs:enumeration value="numpad4"/>
      <xs:enumeration value="numpad5"/>
      <xs:enumeration value="numpad6"/>
      <xs:enumeration value="numpad7"/>
      <xs:enumeration value="numpad8"/>
      <xs:enumeration value="numpad9"/>
      <xs:enumeration value="numpadplus"/>
      <xs:enumeration value="numpadminus"/>
      <xs:enumeration value="numpadmultiply"/>
      <xs:enumeration value="numpaddivide"/>
      <xs:enumeration value="numpadequals"/>
      <xs:enumeration value="numpadperiod"/>
      <xs:enumeration value="numpadenter"/>
    </xs:restriction>
  </xs:simpleType>

  <!--
    ðŸŸª BINDING: User activation mapping

    A Binding maps a keyboard shortcut to a Layout, defining how the user activates
    window tiling. The key attribute specifies the unmodified key (modifiers like
    Shift, Alt, Command, Control are configured elsewhere in the system).

    Traversal behavior:
    When the user holds the modifier chord and repeatedly presses the key, the system
    cycles through all panes (including sub-panes) in the Layout. The traverse
    attribute controls the order of this iteration:

    - First character: primary sort axis ('x' or 'y')
    - Second character: primary direction ('f'=forward/ascending, 'r'=reverse/descending)
    - Third character: secondary sort axis ('y' or 'x')
    - Fourth character: secondary direction ('f' or 'r')

    Examples:
      xfyf = sort by x ascending, then y ascending (left-to-right, top-to-bottom)
      yrxf = sort by y descending, then x ascending (bottom-to-top, left-to-right)

    Mirroring:
    The mirrorX and mirrorY attributes control whether the layout geometry is flipped
    horizontally or vertically when activated via this binding:
      keep = use original geometry
      flip = mirror around center axis

    Example:
      <Binding key="o" layout="sidebar-split" traverse="xfyf" mirrorX="keep" mirrorY="keep"/>
  -->
  <xs:element name="Binding">
    <xs:complexType>
      <xs:attribute name="key" type="KeyType" use="required"/>
      <xs:attribute name="layout" type="xs:string" use="required"/> <!-- references Layout/@id -->
      <xs:attribute name="traverse" use="required">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <!-- 8 legal traversal tokens -->
            <xs:enumeration value="xfyf"/>
            <xs:enumeration value="xfyr"/>
            <xs:enumeration value="xryf"/>
            <xs:enumeration value="xryr"/>
            <xs:enumeration value="yfxf"/>
            <xs:enumeration value="yfxr"/>
            <xs:enumeration value="yrxf"/>
            <xs:enumeration value="yrxr"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="mirrorX" use="required">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="keep"/>
            <xs:enumeration value="flip"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="mirrorY" use="required">
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="keep"/>
            <xs:enumeration value="flip"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

</xs:schema>
